#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Referrence
# http://blog.csdn.net/hikobe8/article/details/50479669
#递归经典案例汉诺塔 python实现
# http://www.cnblogs.com/yanlingyin/archive/2011/11/14/2247594.html
#Hanoi Tower 汉诺塔的简单分析/C


#汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

#有一个梵塔，塔内有三个座A、B、C，A座上有诺干个盘子，盘子大小不等，大的在下，小的在上。
#
#把这些个盘子从A座移到C座，中间可以借用B座但每次只能允许移动一个盘子，并且在移动过程中，3个座上的盘子始终保持大盘在下，小盘在上。
#
#描述简化：把A柱上的n个盘子移动到C柱，其中可以借用B柱。
#看3个的例子
"""
Step 0
--------------------------------------------------
       =|=          |           |   
      ==|==         |           |   
     ===|===        |           |   
Step 1
--------------------------------------------------
        |           |           |   
      ==|==         |           |   
     ===|===        |          =|=  
Step 2
--------------------------------------------------
        |           |           |   
        |           |           |   
     ===|===      ==|==        =|=  
Step 3
--------------------------------------------------
        |           |           |   
        |          =|=          |   
     ===|===      ==|==         |   
Step 4
--------------------------------------------------
        |           |           |   
        |          =|=          |   
        |         ==|==      ===|===
Step 5
--------------------------------------------------
        |           |           |   
        |           |           |   
       =|=        ==|==      ===|===
Step 6 
--------------------------------------------------
        |           |           |   
        |           |         ==|== 
       =|=          |        ===|===
Step 7
--------------------------------------------------
        |           |          =|=  
        |           |         ==|== 
        |           |        ===|===
--------------------------------------------------
"""

#请编写move(n, a, b, c)函数，A、B、C为三个柱子
#汉诺塔就是利用用中间的柱子把最左边的柱子上的圆盘依次从大到小叠上去，说白了就是c要跟原来的a一样 
#它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量，
#然后打印出把所有盘子从A借助B(buffer)移动到C的方法
# 利用递归函数移动汉诺塔:
def move(n, a, buffer, c):
    #初始状态0　　A：按顺序堆放的n个盘子。B:空的。C：空的。
    if n == 1:
        print('Move', n,'Plate From', a, 'to -->', c)
        return
    move(n-1, a, c, buffer) 
    #状态1：A：只有最大的一个盘子。B：有按规则堆放的n-1个盘子。C空的。通过执行函数：a上的n-1挪动到buffer
    print('Move', n,'Plate From', a, 'to -->', c)
    move(n-1, buffer, a, c)
    #状态2：　A：有按顺序堆放的n-1个盘子。B：空的。C：按顺序堆放的第n盘子(可看为空柱)。通过执行函数：buffer上的n-1挪动到c

move(4, 'A', 'B', 'C')
move(3, 'A', 'B', 'C')

n=int(input("请输入盘子数量："))
move(n,"a","b","c")


"""
# 首先是定义了一个移动的函数,四个参数分别代表，a柱上的盘子个数，buffer也就是b柱，命名为buffer便于理解，顾名思义就是一个a移动到c的缓冲区.然后c就是目标柱子 

# 下面我们来读函数代码 

# 递归的一般写法，肯定有个中止递归循环的条件，所以在判断a柱上的盘子个数为1的时候既可以中止递归并返回,a柱上面只有一个的时候肯定就是把a移动到c了.

重点是下面的代码，递归其实是一种很抽象的算法，我们要利用抽象思维去想汉诺塔这个问题，把a柱上的盘子想成两份，就是上面的盘子和最底下的最大的盘子

我们不关心上面的盘子到底有几个，我们每次的操作就是把最底下的盘子通过缓冲区 b柱 buffer 移动到c柱。

童鞋们肯定在想为啥要酱紫移动呢，其实这是一种总结归纳吧，你自己玩一下汉诺塔游戏就会发现规律：
1. 不停的把a上的所有的盘子（n-1）通过c作为暂存区移动到b，按照从小到大的顺序排放，留下最大的一个在a上：move(n-1, a, c, buffer)
2. 然后把底下最后最大的那1个移动到c(按照n==1一个盘子a->c处理)：move(1, a, buffer, c)
3. 不停的把b上的所有的盘子（n-2）通过c作为暂存区移动到移动到a，留下最大的一个在b上： move(n-1, buffer , a, c)
4. 然后把b底下最后最大的那1个移动到c
5. 开始重复Step 1 to Step 4

这里规律就体现出来了，也可以抽象出移动的方法，并可以以此设计出程序算法。以下我们来利用刚才的抽象思维解读剩余代码

1. move(n-1, a, c, buffer)
这段代码就是表示把刚才所说的a柱的上面的n-1个，通过c作为暂存区，按照从小到大的规则先移动到缓冲区buffer。此函数进入递归。

2. move(1, a, buffer, c)
当上面的语句执行完成，也就是n-1个盘子的递归移动完成之后，执行此语句，就是把a柱上的一个盘子移动到c,也就是所谓的a最底下的盘子

3. move(n-1, buffer , a, c)
刚才把a上面的n-1个都移动到了buffer上面，a上是空的，肯定要通过a移动b上的n-2个到a，留下最大的一个。此函数进入递归。

到c才能完成整个汉诺塔的移动啊，于是最后一步自然是把刚才的n-1个通过a当缓冲区移动到c柱上.


"""

#我来写下整个移动流程，以a柱上有3个为例子

"""
我把3个盘子的汉诺塔全部通过代码演示，按缩进原则，每一个缩进即进一个递归函数，每打印一次即中止当前递归,也就是每个print
说明:
    1.n = 3, n = 2, n = 1是每次执行if(n == 1)的结果，这里就不写判断了，相信童鞋们也能看懂，也就是n不等与1时就减1进入递归
    2.请注意a,b,c柱每次进入函数的顺序，不要被形参带错路了，看准每次函数参数的实参 
"""
move(3, "a", "b", "c")
n=3:
    #开始从a上移动n-1即2个盘子通过c移动到b,以腾出c供a最后一个盘子移动
    move(2, "a","c","b")
    n=2:
    #开始进行n=2的一个递归，把当前a('a')柱上的n-1个盘子通过c('b'）移动到b('c')
        move(1, "a", "b", "c")
        n=1:
        #n=2的第一个递归完成,打印结果，执行当前子函数剩余代码
            print("a", "->", "c") 
        move(1, "a", "c", "b")
        n=1:
            print("a", "->", "b")
        move(1, "c", "a", "b")
        n=1:
            print("c", "->", "b")
    　   #到这里完成了a柱上面的n-1即是2个盘子的移动
#开始把a柱上最后一个盘子移动到c柱上
move(1, "a", "b", "c")
n=1:
    print("a", "->", "c")
    #到这里完成移动a柱上的最后一个盘子到c柱上 
move(2, "b", "a", "c")
n=2:
#开始进行n=2的第二个递归,即把当前b('b')的盘子(n-1个)通过a('a')移动到c('c')上
    move(1, "b", "c", "a")
    n=1:
    #n=2 的第二个递归完成，打印结果并执行当前子函数的剩余代码
        print("b", "->", "a")
    move(1, "b", "a", "c")
    n=1:
        print("b", "->", "c")
    move(1, "a", "b", "c")
    n=1:
        print("a", "->", "c")
        #到这里把b上的盘子通过a移动到c,
#整个代码执行完毕,汉诺塔移动完成


#利用python实现的汉诺塔。带有图形演示
from time import sleep
def disp_sym(num, sym):
        print(sym*num, end='')
#recusion
def hanoi(a, b, c, n, tray_num):
 if n == 1:
  move_tray(a, c)
  disp(tray_num)
  sleep(0.7)
 else:
  hanoi(a, c, b, n-1, tray_num)
  move_tray(a, c)
  disp(tray_num)
  sleep(0.1)
  hanoi(b, a, c, n-1, tray_num)
def move_tray(a, b):
 for i in a:
  if i != 0:
   for j in b:
    if j != 0:
     b[b.index(j) - 1] = i
     a[a.index(i)] = 0
     return
   b.append(i)
   b.pop(0)
   a[a.index(i)] = 0
   return

def disp(tray_num):
 global a, b, c
 for i in range(tray_num):
  for j in ['a', 'b', 'c']:
   disp_sym(5, ' ')
   eval('disp_sym(tray_num - ' + j + "[i], ' ')")
   eval('disp_sym(' + j + "[i], '=')")
   disp_sym(1, '|')
   eval('disp_sym(' + j + "[i], '=')")
   eval('disp_sym(tray_num - ' + j + "[i], ' ')")
  print()
 print('--------------------------------------------------')
tray_num=int(input("Please input the number of trays:"))
tray=[]
for i in range(tray_num):
 tray.append(i + 1)
a=[0]*tray_num
b=a[:]
c=a[:]
a = tray[:]
disp(tray_num)
hanoi(a, b, c, tray_num, tray_num)



"""
我们直接假设有n个盘子：

先把盘子从小到大标记为1、2、3......n

先看原问题三个柱子的状态：
  
状态0
A：按顺序堆放的n个盘子。B:空的。C：空的。

目标是要把A上的n个盘子移动到C。因为必须大的在下小的在上，所以最终结果C盘上最下面的应该是标号为n的盘子，试想：

要取得A上的第n个盘子，就要把它上面的n-1个盘子拿开吧？拿开放在哪里呢？共有三个柱子：A显然不是、如果放在C上

了，那么最大的盘子就没地方放，问题还是没得到解决。所以选择B柱。当然，B上面也是按照大在下小在上的原则堆放的

（记住：先不要管具体如何移动，可以看成用一个函数完成移动，现在不用去考虑函数如何实现。这点很重要）。

很明显：上一步完成后三个塔的状态：

状态1：
A：只有最大的一个盘子。B：有按规则堆放的n-1个盘子。C空的。

上面的很好理解吧，好，其实到这里就已经完成一半了。（如果前面的没懂，请重看一遍。point：不要管如何移动！）

我们继续：
这时候，可以直接把A上的最大盘移动到C盘，移动后的状态：

中间状态：
A：空的。B：n-1个盘子。C：有一个最大盘（第n个盘子）

要注意的一点是：这时候的C柱其实可以看做是空的。因为剩下的所有盘子都比它小，它们中的任何一个都可以放在上面，也就是C柱上。

所以现在三个柱子的状态：

中间状态：
A：空的。B：n-1个盘子。C：空的

想一想，现在的问题和原问题有些相似之处了吧？。。如何更相似呢？。显然，只要吧B上的n-1个盘子移动到A，待解决的问题和原问题就相比就只是规模变小了

现在考虑如何把B上的n-1个盘子移动到A上，其实移动方法和上文中的把n-1个盘从A移动到B是一样的，只是柱子的名称换了下而已。。（如果写成函数，只是参数调用顺序改变而已）。　

假设你已经完成上一步了（同样的，不要考虑如何去移动，只要想着用一个函数实现就好），请看现在的状态：

状态2：
A：有按顺序堆放的n-1个盘子。B：空的。C：按顺序堆放的第n盘子(可看为空柱)

就在刚才，我们完美的完成了一次递归。如果没看懂请从新看一遍，可以用笔画出三个状态、静下心来慢慢推理。

我一再强调的：当要把最大盘子上面的所有盘子移动到另一个空柱上时，不要关心具体如何移动，只用把它看做一个函数可以完成即可，不用关心函数的具体实现。如果你的思路纠结在这里，就很难继续深入了。

到这里，其实 基本思路已经理清了。状态2和状态0，除了规模变小 ，其它方面没有任何区别了。然后只要用相同的思维方式，就能往下深入。。。

好了，看看如何用算法实现吧：

定义函数Hanoi（a,b,c,n）表示把a上的n个盘子移动到c上，其中可以用到b。

定义函数move(m,n)表示把m上的盘子移动到n上

我们需要解决的问题正是　　Hanoi (a,b,c,n)   　　//上文中的状态0

1、把A上的n-1个移动到B：  　　Hanoi (a,c,b,n-1);       // 操作结束为状态1

2、把A上的大盘子移动到C         move(a,c)　　　　

3、把B上的n-1移动到A　　　　　Hanoi (b,c,a,n-1);　　//操作结束位状态2(和状态1相比只是规模变小)

如果现在还不能理解、请回过头再看一遍、毕竟如果是初学者不是很容易就能理解的。可以用笔记下几个关键的状态，并且看看你有没有真正的投入去看，独立去思考了。


给出算法C代码：
main()
{
    int n;
    printf("请输入数字n以解决n阶汉诺塔问题：\n");
    scanf("%d",&n);
    hanoi(n,'A','B','C');
}

void hanoi(char A,char B,char C,int n)
{
    if(n==1)
    {
      printf("Move disk %d from %c to %c\n",A,C,n);
    }
    else
    {
      hanoi(A,C,B, n-1);
      printf("Move disk %d from %c to %c\n",n,A,C);
      hanoi(B,A,C,n-1,);
    }
}

//以上代码c-free5编译通过。
//代码出处：http://www.cnblogs.com/yanlingyin/ 一条鱼~

对递归的一点理解：

解决实际问题时、不能太去关心实现的细节（因为递归的过程恰恰是我们实现的方法）就像这个问题，如在第一步就过多的纠结于如何把n-1个盘子移动到B上、那么你的思路就很难继续深入。只要看做是用函数实现就好，如果你能看出不管怎么移动，其实本质都一样的时候，那么就能较快的得到结果了。就像这个案例，要注意到我们做的关键几步都只是移动的顺序有改变，其中的规则没有改变，如果用函数表示的话，就只是参数调用的顺序有所不同了。在递归的运用中、不用关心每一步的具体实现 ，只要看做用一个函数表示就好。分析问题的时候，最好画出自己的推理过程，得到有效的状态图。

思考问题讲求思路的连贯性、力求尽快进入状态，享受完全投入到一件事中的美妙感觉。


"""

"""
要理解递归首先你得理解递归。
递归题就是找感觉，要有要把大象装冰箱总共分几步？这样的思维方式，
一但去抠细节你就中计了。

汉诺塔问题有三根柱子，我给它们分别命名为起始柱src，临时柱tmp，目的柱dst
盘子一共分两种情况：
1.只有1个盘子
这种情况下，直接从起始柱src 移动到 目的柱dst ,完成任务。

2.有1个以上的盘子
假如有n个盘子在起始柱，

首先把第n个盘子上方的n-1个盘子搬到临时柱。
然后把第n个盘子从起始柱移动到目的柱
最后把n-1个盘子从临时柱搬到目的柱 任务完成
知道这些就够了，千万别XJB去想细节！！！
知道这些就够了，千万别XJB去想细节！！！
知道这些就够了，千万别XJB去想细节！！！
"""

def move(PlateNo,from1,to1): #将盘子从from移动到to，动画效果需要脑补
    print('Move Plate', PlateNo, 'from', from1, '-> to', to1)

def hanoi(n, src, tmp, dst):#将n个盘子从src=a搬到dst=c
    if n == 1: #只有一个盘子的情况
        move(n, src, dst)
    else: #有一个以上盘子的情况
        hanoi(n-1,src,dst,tmp) #将上方的n-1个盘子从src=a搬到tmp=b
        move(n, src, dst) #将第n个盘子从src轻松愉快地移动到dst
        hanoi(n-1, tmp, src, dst) #擦屁股，将tmp上(此时是移动的源，看函数的形参)的n-1个盘子搬到dst上
        
hanoi(2,'A','B','C')
hanoi(3,'A','B','C')
hanoi(4,'A','B','C')
hanoi(5,'A','B','C')

def move(n, a, buffer, c):
    #初始状态0　　A：按顺序堆放的n个盘子。B:空的。C：空的。
    if n == 1:
        print('Move', n,'Plate From', a, 'to -->', c)
        return
    move(n-1, a, c, buffer) 
    #状态1：A：只有最大的一个盘子。B：有按规则堆放的n-1个盘子。C空的。通过执行函数：a上的n-1挪动到buffer
    print('Move', n,'Plate From', a, 'to -->', c)
    move(n-1, buffer, a, c)
    #状态2：　A：有按顺序堆放的n-1个盘子。B：空的。C：按顺序堆放的第n盘子(可看为空柱)。通过执行函数：buffer上的n-1挪动到c

move(4, 'A', 'B', 'C')
move(3, 'A', 'B', 'C')

n=int(input("请输入盘子数量："))
move(n,"a","b","c")


#比如构造一个1, 3, 5, 7, ..., 99的列表，可以通过循环实现：

L = []
n = 1
while n <= 99:
    L.append(n)
    n = n + 2
print(L)

def listBuild(count):
    L = []
    n = 1
    while n <= count:
        L.append(n)
        n = n + 2
    return print(L)    

listBuild(9)
listBuild(99)